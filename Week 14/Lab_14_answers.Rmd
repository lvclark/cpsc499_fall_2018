---
title: "Lab 14"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r message = FALSE, warning = FALSE}
library(VariantAnnotation)
library(GenomicFeatures)
```

In this lab we'll do more work with the import and manipulation of VCFs.

## File for today

From Compass, download "Msi_genotypes2.vcf.bgz".  This VCF was created by the
[TASSEL-GBSv2 pipeline](https://bitbucket.org/tasseladmin/tassel-5-source/wiki/Tassel5GBSv2Pipeline)
from RAD-seq data of 585 diverse *Miscanthus sinensis* accessions.  It was 
filtered to only retain SNPs with non-missing data for at least 400 
individuals, and at least 20 individuals with the minor allele.  SNPs that did
not align to one of the 19 chromosomes were discarded.  It was also
bgzipped to make it easier to upload and download.

We can index it as well so that it can be used as a Tabix file.

```{r}
myfile <- "Msi_genotypes2.vcf.bgz"
```

```{r eval = FALSE}
indexTabix(myfile, format = "vcf")
```

Without loading the whole thing, we can get some basic info using `scanVcfHeader`.

```{r}
hdr <- scanVcfHeader(myfile)
hdr
geno(hdr)
```

We can also import a few lines for a preview.  (For some reason with the 
bgzip format, we get extra blank lines, which is why we are skipping some.)

```{r}
testlines <- readLines(myfile, 300)[seq(1, 298, by = 3)]
cat(testlines[1:10], sep = "\n") # header
cat(substring(testlines[11], 1, 200), sep = "\n") # column headers
genotype_lines <- testlines[12:100]
cat(substring(genotype_lines[1], 1, 200), sep = "\n") # genotype preview
```

## Reference genome setup

Index the reference genome, then set it up as a `FaFile`.

```{r eval = FALSE}
# indexing; run this once, then comment it out
indexFa("Msinensis_497_v7.0.hardmasked.fa.gz") 
```

```{r}
miscanthus_genome <- FaFile("Msinensis_497_v7.0.hardmasked.fa.gz")
seqinfo(miscanthus_genome)
```

Because the VCF file was generated by TASSEL, we will have to work around the
fact that TASSEL shortened the chromosome names, especially if we are referring
back to the reference genome.

```{r}
substring(genotype_lines[1:10], 1, 5) # two digit chromosome name (01)
```

Later in the lab there will be a few things we do to fix this discrepancy.

## Filtering to a smaller file

Back in Lab 5, you read through a VCF file and used `gregexpr` to determine
how much missing data there was, then depending on the results you wrote each
line to an output file or discarded it.

That algorithm can be repurposed into a function that can be used with
`prefilter` in `filterVcf`.  The function should have the following components:

* Accepts a single argument, which is a vector of lines from the VCF file 
below the `#CHROM` line.  (Don't worry about dealing with header lines.)
* Uses `gregexpr` to count up missing data, similarly to Lab 5.  The regular
expression here is `"\t\\./\\.:"` since missing genotypes are coded `./.`.
* Uses `sapply` with `length` on the output of `gregexpr` to get a vector
of the number of individuals with missing data for each SNP.
* Creates a Boolean vector to indicate whether fewer than 50 individuals
had missing data.
* Returns that Boolean vector.

```{r echo = TRUE}
# Function to accept VCF file lines, and return TRUE if there are fewer than 50
# individuals with missing data, and FALSE otherwise.
lessThan50Missing <- function(x){
  matches <- gregexpr("\t\\./\\.:", x)
  missCount <- sapply(matches, length)
  return(missCount < 50)
}
```

Then we can see how the function works on the example lines that we imported
earlier.  In this case I named the function `lessThan50Missing`.

```{r}
testres <- lessThan50Missing(genotype_lines)
testres[1:10]
mean(testres)
```

Now you can use that function with `filterVcf`.  This will take a few 
minutes and makes a 1.3 Gb file, which we will then compress and index.

```{r eval = FALSE}
filterVcf(myfile, "Miscanthus sinensis v7", "Msi_genotypes_filtered.vcf",
          prefilters = FilterRules(list(lessThan50Missing)))
bgzip("Msi_genotypes_filtered.vcf")
indexTabix("Msi_genotypes_filtered.vcf.bgz", format = "vcf")
```

**Question 1 to turn in:**  Turn in your code for the `lessThan50Missing`
function.

## Importing specific regions and fields

Say we want specifically to look for protein coding changes in our VCF.  So, we
might as well save some RAM and only import SNPs within the CDS regions.

**Question 2 to turn in:** Use the Msinensis GFF3 file to make a `GRanges` object
indicating the locations of all CDS in the *M. sinensis* reference genome.
(Hint: an intermediate step is building a `TxDb` object.)

```{r echo = TRUE, message = FALSE}
miscanthus_genes <- makeTxDbFromGFF("Msinensis_497_v7.1.gene_exons.gff3.gz",
                                    format = "gff3", dataSource = "Phytozome 12",
                                    organism = "Miscanthus sinensis",
                                    chrominfo = seqinfo(miscanthus_genome))
Msi_CDS <- cds(miscanthus_genes)
```

**Rest of exercise (not part of Question 2)**

In the code below I'll call this `GRanges` object `Msi_CDS`.  We'll change the 
chromsome names in `Msi_CDS` to match those in the VCF file.

```{r}
seqlevels(Msi_CDS) <- sub("Chr", "", seqlevels(Msi_CDS))
```

To make the lab go a bit faster we can also just look at CDS on chromosome 12.

```{r}
Msi_CDS_Chr12 <- subsetByOverlaps(Msi_CDS, 
                                  GRanges("12", IRanges(1, 85543828)),
                                  type = "within")
```

Of course if we are looking for coding mutations, we want to know chromosome,
position, reference and alternative allele.  We can import individual genotypes
too so that we can explore those.  But maybe we don't care about all the other
information in the file.  We'll build a `ScanVcfParam` object to indicate what
fields we want.  We can also indicate which samples to keep in the genotypes
table.

```{r}
myparam <- ScanVcfParam(fixed = "ALT", info = NA, geno = "GT", 
                        which = Msi_CDS_Chr12,
                        samples = c("PI417947-NG77-022", "PMS-049",
                                    "UI10-00104-Zwergzebra" ))
```

CHROM, POS, ID, and REF are imported no matter what, so we didn't need to
indicate those.  By setting `info = NA` we indicate that we don't want anything
from the INFO column.  `geno = "GT"` gets the genotypes.  `which` is used for
indicating which genomic regions we want.

Now we can read the VCF.  We have to build a `SeqInfo` object to match the
chromosome names that we are using, and send it to the `genome` argument.
We'll also read the file as a `TabixFile` since that speeds things up a little.

```{r cache = TRUE}
mytabix <- TabixFile("Msi_genotypes_filtered.vcf.bgz")
myvcf <- readVcf(mytabix,
                 genome = Seqinfo(seqnames = names(vcfWhich(myparam))), 
                 param = myparam)
myvcf
```

Now that we have the VCF imported, we can fix the sequence names to match our
reference genome.

```{r}
seqlevels(myvcf) <- seqlevels(miscanthus_genome)
```


## Predicting coding changes

Now we can predict protein coding changes that will be caused by these SNPs.
Ignore the warning that you get.

```{r message = FALSE, warning = FALSE}
pred <- predictCoding(myvcf, miscanthus_genes, miscanthus_genome)
pred
```

**Question 3 to turn in:**  Find the names of all unique SNPs that cause 
nonsynonymous, nonsense, or frameshift mutations. How many of these have a
non-reference allele
in the individual PI417947-NG77-022?  The `%in%` operator and the `unique` function
might be helpful.  Turn in the code that you used.

```{r echo = TRUE}
pred2 <- pred[pred$CONSEQUENCE %in% c("nonsynonymous", "nonsense", "frameshift")]
snpnames <- unique(names(pred2))
NG7722gen <- geno(myvcf)$GT[snpnames, "PI417947-NG77-022"]
sum(!NG7722gen %in% c("0/0", "."))
```

